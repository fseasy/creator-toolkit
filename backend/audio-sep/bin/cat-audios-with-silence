#!/usr/bin/env python3
import sys
import subprocess
import json
import argparse
import tempfile
import re
from pathlib import Path

# 编码器映射表：ffprobe 探测到的 codec_name 有时不能直接作为 -c:a 的参数
# 这里做一个映射，确保使用正确的编码器生成静音
CODEC_MAP = {
    "mp3": "libmp3lame",
    "opus": "libopus",
    "vorbis": "libvorbis",
    "aac": "aac",
    "flac": "flac",
    "pcm_s16le": "pcm_s16le",
    "pcm_s24le": "pcm_s24le",
    "pcm_f32le": "pcm_f32le",
}

def check_ffmpeg_installed():
    try:
        subprocess.run(["ffmpeg", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        subprocess.run(["ffprobe", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def get_audio_properties(file_path: Path):
    """
    获取音频文件的采样率、声道数、以及编码名称(codec_name)
    """
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "a:0",
        "-show_entries", "stream=sample_rate,channels,codec_name",
        "-of", "json",
        str(file_path)
    ]
    try:
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        data = json.loads(result.stdout)
        if not data.get('streams'):
            raise ValueError("No audio stream found")
        stream = data['streams'][0]
        return {
            "sample_rate": int(stream.get('sample_rate', 44100)),
            "channels": int(stream.get('channels', 2)),
            "codec_name": stream.get('codec_name', 'pcm_s16le')
        }
    except Exception as e:
        print(f"Warning: 无法探测文件 {file_path.name}: {e}，将尝试使用默认参数。")
        return {"sample_rate": 44100, "channels": 2, "codec_name": "pcm_s16le"}

def generate_matching_silence(output_path: Path, duration_sec: float, props: dict):
    """
    生成与源文件编码一致的静音文件。
    关键修复：使用与源文件相同的编码器 (codec)。
    """
    sr = props['sample_rate']
    ch = props['channels']
    codec_name = props['codec_name']
    
    # 查找映射，如果找不到就直接用探测到的名称（通常也行）
    encoder = CODEC_MAP.get(codec_name, codec_name)
    
    layout = "mono" if ch == 1 else "stereo"
    
    print(f"   -> 正在生成静音: 格式={codec_name} (编码器={encoder}), 采样率={sr}, 声道={ch}")

    cmd = [
        "ffmpeg", "-y", "-hide_banner", "-loglevel", "error",
        "-f", "lavfi",
        "-i", f"anullsrc=r={sr}:cl={layout}",
        "-t", str(duration_sec),
        "-c:a", encoder,
        str(output_path)
    ]
    
    # Opus 放在 mp4/wav 容器里有时有问题，如果不指定 strictly standard compliant
    # 但通常 ffmpeg 会自动处理。如果报错，可能需要增加 -strict -2
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError:
        print(f"警告: 无法使用编码器 '{encoder}' 生成静音。尝试回退到 PCM...")
        # 如果对应的编码器失败（比如没有安装 libopus），回退到 pcm，
        # 但这样拼接可能会再次报错，所以这是一个尽力而为的操作。
        cmd[cmd.index(encoder)] = "pcm_s16le"
        subprocess.run(cmd, check=True)

def parse_input_line(line: str) -> str:
    line = line.strip()
    match = re.match(r"^file\s+(['\"]?)(.+?)\1$", line)
    if match:
        return match.group(2)
    return line

def escape_ffmpeg_path(path: Path) -> str:
    path_str = path.as_posix()
    path_str = path_str.replace("'", "'\\''")
    return path_str

def main():
    parser = argparse.ArgumentParser(description="高效拼接N个音频文件（自动匹配编码防崩溃版）。")
    parser.add_argument("list_file", type=Path, help="文件列表 (.txt)")
    parser.add_argument("output_path", type=Path, help="输出文件路径")
    parser.add_argument("--silence", "-s", type=float, default=1.0, help="静音时长(秒)")
    
    args = parser.parse_args()

    if not check_ffmpeg_installed():
        print("错误: 请先安装 FFmpeg。")
        sys.exit(1)

    # 路径处理
    list_file_abs = args.list_file.resolve()
    base_dir = list_file_abs.parent
    
    if not args.output_path.is_absolute():
        output_file_abs = base_dir / args.output_path
    else:
        output_file_abs = args.output_path

    if not list_file_abs.exists():
        print(f"错误: 找不到 {list_file_abs}")
        sys.exit(1)

    # 读取列表
    audio_files = []
    with list_file_abs.open('r', encoding='utf-8') as f:
        for line in f:
            if not line.strip(): continue
            fname = parse_input_line(line)
            audio_files.append(base_dir / fname)

    if not audio_files:
        print("列表为空。")
        sys.exit(1)

    first_file = audio_files[0]
    if not first_file.exists():
        print(f"错误: 第一个文件不存在: {first_file}")
        sys.exit(1)

    # 核心修复流程
    with tempfile.TemporaryDirectory() as temp_dir_str:
        temp_dir = Path(temp_dir_str)
        
        # 1. 探测第一个文件的详细参数
        print(f"正在分析源文件格式: {first_file.name}")
        props = get_audio_properties(first_file)
        
        # 2. 生成静音文件
        # 为了最大程度兼容 concat demuxer，静音文件的后缀名最好和源文件一致
        # 例如源文件是 .ogg (opus)，静音文件也叫 .ogg
        input_ext = first_file.suffix
        silence_file = temp_dir / f"generated_silence{input_ext}"
        
        generate_matching_silence(silence_file, args.silence, props)
        
        # 3. 构建列表
        concat_list_file = temp_dir / "concat_list.txt"
        with concat_list_file.open('w', encoding='utf-8') as f:
            for i, audio_path in enumerate(audio_files):
                if not audio_path.exists():
                    print(f"跳过丢失文件: {audio_path}")
                    continue
                
                f.write(f"file '{escape_ffmpeg_path(audio_path)}'\n")
                
                # 每个文件后加静音（除了最后一个可选，这里默认都加，如果需要微调请手动修改逻辑）
                f.write(f"file '{escape_ffmpeg_path(silence_file)}'\n")

        # 4. 执行拼接
        print(f"开始拼接 -> {output_file_abs.name} ...")
        
        # 自动选择输出编码
        out_ext = output_file_abs.suffix.lower()
        
        # 如果输出也是 opus/ogg 且输入也是 opus，理论上可以用 -c copy
        # 但为了保险起见（避免不同 opus 文件的 timestamp 间断问题），
        # 还是建议重编码输出，或者使用 -c copy 配合 -ignore_unknown
        # 为了稳健性，这里默认进行重编码（Re-encoding），这比解码+Python处理还是快得多。
        
        codec_args = ["-c:a", "libmp3lame", "-q:a", "2"] # 默认 MP3
        if out_ext == ".wav":
            codec_args = ["-c:a", "pcm_s16le"]
        elif out_ext in [".m4a", ".aac", ".mp4"]:
            codec_args = ["-c:a", "aac", "-b:a", "192k"]
        elif out_ext in [".ogg", ".opus"]:
            codec_args = ["-c:a", "libopus", "-b:a", "128k"]

        ffmpeg_cmd = [
            "ffmpeg", "-y", "-hide_banner", "-loglevel", "info",
            "-f", "concat",
            "-safe", "0",
            "-i", str(concat_list_file),
        ] + codec_args + [str(output_file_abs)]

        try:
            subprocess.run(ffmpeg_cmd, check=True)
            print("✅ 处理完成！")
        except subprocess.CalledProcessError as e:
            print(f"❌ 拼接失败。FFmpeg 退出码: {e.returncode}")
            print("提示: 如果依然报错，可能是因为源文件列表中包含不同编码的文件。concat 模式要求所有输入文件编码完全一致。")

if __name__ == "__main__":
    main()
